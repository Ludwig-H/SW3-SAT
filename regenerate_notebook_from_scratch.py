import json

notebook = {
    "cells": [],
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.8.5"
        },
        "colab": {
            "provenance": [],
            "gpuType": "A100"
        },
        "accelerator": "GPU"
    },
    "nbformat": 4,
    "nbformat_minor": 0
}

def add_cell(source_code, cell_type="code"):
    lines = [line + "\n" for line in source_code.splitlines()]
    if lines: lines[-1] = lines[-1].rstrip("\n")
    cell = {
        "cell_type": cell_type,
        "metadata": {},
        "source": lines
    }
    if cell_type == "code":
        cell["execution_count"] = None
        cell["outputs"] = []
    notebook["cells"].append(cell)

# --- CELL 1: Header ---
add_cell("# Stochastic Higher-Order Swendsen-Wang vs WalkSAT\n\nThis notebook compares our **Stochastic Cluster Monte Carlo** algorithm against the industry standard for Random SAT: **WalkSAT**. \n\n## The Contenders\n1.  **Stochastic Swendsen-Wang (Ours)**:\n    *   Physics-based (Cluster Dynamics).\n    *   Uses geometric frustration and percolation.\n    *   **New**: Uses **Exact Hamiltonian Cluster Updates** (Exact Energy Delta) for decision.\n    *   **Schedule**: Logarithmic annealing (dense near $\\omega_{max}$).\n    *   Runs on GPU (Massively Parallel).\n2.  **WalkSAT (Reference)**:\n    *   Stochastic Local Search.\n    *   Greedy + Noise heuristic.\n    *   Runs on CPU (Sequential, fast flips).\n3.  **Dynamics UNSAT (New)**:\n    *   Focuses dynamics on clusters touching UNSAT clauses.\n", cell_type="markdown")

# --- CELL 2: Setup ---
add_cell("# @title 1. Environment & GPU Setup\nimport sys\nimport os\nimport subprocess\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport requests\nimport tarfile\nimport io\nimport gzip\nimport random\n\n# Ensure CuPy is available\ntry:\n    import cupy as cp\n    import cupyx.scipy.sparse as cpx\n    import cupyx.scipy.sparse.csgraph as cpx_graph\n    print(f"GPU Detected: {cp.cuda.runtime.getDeviceCount()} device(s)")\nexcept ImportError:\n    print("Installing CuPy...")\n    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'cupy-cuda12x'])\n    import cupy as cp\n    import cupyx.scipy.sparse as cpx\n    import cupyx.scipy.sparse.csgraph as cpx_graph\n\nplt.style.use('dark_background')\nprint("Environment Ready.")")

# --- CELL 3: Generators ---
add_cell("# @title 2. Data Generators (Random & SATLIB)\n\ndef generate_random_3sat(N, alpha, seed=None):\n    if seed is not None: np.random.seed(seed)\n    M = int(N * alpha)\n    vars = np.random.randint(1, N + 1, size=(M, 3))\n    signs = np.random.choice([-1, 1], size=(M, 3))\n    return vars * signs, N")

# --- CELL 4: Metropolis Kernel Code (Shared) ---
add_cell("# @title 3. Shared Kernels\n\nmetropolis_kernel_code = r'''\n#include <curand_kernel.h>\n\nextern \"C\" __global__ void run_metropolis_dynamics(\n    signed char* sigma,           // N+1\n    const int* c2c_indptr,        // n_comps + 1\n    const int* c2c_indices,       // n_clauses_refs\n    const int* c2v_indptr,        // n_comps + 1\n    const int* c2v_indices,       // n_vars_refs\n    const int* lits_idx,          // M * 3\n    const signed char* lits_sign, // M * 3\n    const int* lit_clusters,      // M * 3\n    const int* valid_clusters,    // num_valid\n    int num_valid,\n    int steps,\n    float omega,\n    float beta_scale,\n    unsigned long long seed\n) {\n    __shared__ int delta_E_shared;\n    __shared__ int decision_shared;\n    __shared__ int target_cluster_shared;\n\n    curandState state;\n    if (threadIdx.x == 0) {\n        curand_init(seed, 0, 0, &state);\n    }\n\n    for (int step = 0; step < steps; step++) {\n        __syncthreads();\n\n        if (threadIdx.x == 0) {\n            delta_E_shared = 0;\n            decision_shared = 0;\n            unsigned int r = curand(&state);\n            int r_idx = r % num_valid;\n            target_cluster_shared = valid_clusters[r_idx];\n        }\n        __syncthreads();\n\n        int c_id = target_cluster_shared;\n        int start_c = c2c_indptr[c_id];\n        int end_c = c2c_indptr[c_id+1];\n\n        if (start_c < end_c) {\n            for (int i = start_c + threadIdx.x; i < end_c; i += blockDim.x) {\n                int clause_idx = c2c_indices[i];\n                int idx0 = clause_idx * 3 + 0;\n                int idx1 = clause_idx * 3 + 1;\n                int idx2 = clause_idx * 3 + 2;\n\n                int l0 = lits_idx[idx0];\n                int l1 = lits_idx[idx1];\n                int l2 = lits_idx[idx2];\n\n                signed char s0 = lits_sign[idx0];\n                signed char s1 = lits_sign[idx1];\n                signed char s2 = lits_sign[idx2];\n\n                signed char sig0 = sigma[l0];\n                signed char sig1 = sigma[l1];\n                signed char sig2 = sigma[l2];\n\n                int cl0 = lit_clusters[idx0];\n                int cl1 = lit_clusters[idx1];\n                int cl2 = lit_clusters[idx2];\n\n                bool sat_curr = (sig0 == s0) || (sig1 == s1) || (sig2 == s2);\n\n                signed char p_sig0 = (cl0 == c_id) ? -sig0 : sig0;\n                signed char p_sig1 = (cl1 == c_id) ? -sig1 : sig1;\n                signed char p_sig2 = (cl2 == c_id) ? -sig2 : sig2;\n\n                bool sat_new = (p_sig0 == s0) || (p_sig1 == s1) || (p_sig2 == s2);\n\n                if (sat_curr != sat_new) {\n                    atomicAdd(&delta_E_shared, (int)sat_curr - (int)sat_new);\n                }\n            }\n        }\n        __syncthreads();\n\n        if (threadIdx.x == 0) {\n            int dE = delta_E_shared;\n            if (dE <= 0) {\n                decision_shared = 1;\n            } else {\n                float p = expf(-(float)dE * omega * beta_scale);\n                float r = curand_uniform(&state);\n                if (r < p) {\n                    decision_shared = 1;\n                }\n            }\n        }\n        __syncthreads();\n\n        if (decision_shared) {\n            int start_v = c2v_indptr[c_id];\n            int end_v = c2v_indptr[c_id+1];\n            for (int i = start_v + threadIdx.x; i < end_v; i += blockDim.x) {\n                sigma[c2v_indices[i]] *= -1;\n            }\n        }\n    }\n}\n'''
add_cell(metropolis_kernel_code)

# --- CELL 5: SwendsenWangErdosRenyiGPU ---
add_cell("# @title 3a. The Solver: `SwendsenWangErdosRenyiGPU`\n\nclass SwendsenWangErdosRenyiGPU:\n    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, a=0.9, dynamics=\"Metropolis\"):\n        self.N = N\n        self.M = len(clauses_np)\n        self.clauses = cp.array(clauses_np)\n        self.beta_scale = beta_scale\n        self.a = a # ErdÅ‘s-RÃ©nyi parameter\n        self.dynamics = dynamics\n        \n        if steps_flips is None:\n            self.steps_flips = 2 * N\n        else:\n            self.steps_flips = steps_flips\n\n        # Literals: Convert 1-based DIMACS to 0-based indices\n        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32) - 1)\n        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))\n\n        # Interactions (Triangles)\n        s = self.lits_sign\n        j01 = cp.where(s[:, 0] == s[:, 1], -1, 1)\n        j12 = cp.where(s[:, 1] == s[:, 2], -1, 1)\n        j20 = cp.where(s[:, 2] == s[:, 0], -1, 1)\n        self.J_tri = cp.stack([j01, j12, j20], axis=1).astype(cp.int8)\n\n        # State (Size N, 0-based)\n        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N)\n        \n        self.best_sigma = self.sigma.copy()\n        self.min_energy = 1.0\n\n        # Kernel\n        self.kernel = cp.RawKernel(metropolis_kernel_code, 'run_metropolis_dynamics', options=('-std=c++17',))\n\n    def energy_check(self):\n        spins = self.sigma[self.lits_idx]\n        is_lit_sat = (spins == self.lits_sign)\n        is_clause_sat = cp.any(is_lit_sat, axis=1)\n        return 1.0 - cp.mean(is_clause_sat)\n\n\n    def _run_dynamics(self, labels, n_comps, omega):\n        # Map Clusters to Clauses\n        lit_clusters = labels[self.lits_idx] # (M, 3)\n        \n        # Valid Clusters: All unique positive labels\n        valid_clusters = cp.unique(labels).astype(cp.int32)\n        valid_clusters = valid_clusters[valid_clusters >= 0]\n        num_valid = len(valid_clusters)\n        \n        if num_valid == 0: return\n\n        # 1. CSR: Cluster -> Vars\n        # Filter out inactive vars (label -1)\n        valid_mask_v = (labels >= 0)\n        active_vars = cp.where(valid_mask_v)[0]\n        active_labels = labels[valid_mask_v]\n        \n        if len(active_vars) == 0: return\n\n        data_v = cp.ones(len(active_vars), dtype=cp.bool_)\n        cluster_to_vars = cpx.coo_matrix(\n            (data_v, (active_labels, active_vars)),\n            shape=(n_comps, self.N)\n        ).tocsr()\n\n        # 2. CSR: Cluster -> Clauses\n        flat_clusters = lit_clusters.flatten()\n        flat_clauses = cp.repeat(cp.arange(self.M), 3)\n        \n        # Filter out pairs where cluster is -1\n        mask_c = (flat_clusters >= 0)\n        flat_clusters = flat_clusters[mask_c]\n        flat_clauses = flat_clauses[mask_c]\n        \n        if len(flat_clusters) == 0: return\n\n        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)\n        unique_keys = cp.unique(combined_keys)\n        \n        u_clusters = (unique_keys // self.M).astype(cp.int32)\n        u_clauses = (unique_keys % self.M).astype(cp.int32)\n        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)\n        \n        cluster_to_clauses = cpx.coo_matrix(\n            (data_c, (u_clusters, u_clauses)),\n            shape=(n_comps, self.M)\n        ).tocsr()\n\n        c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)\n        c2c_indices = cluster_to_clauses.indices.astype(cp.int32)\n        c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)\n        c2v_indices = cluster_to_vars.indices.astype(cp.int32)\n        lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))\n        \n        seed = int(time.time() * 1000) % 1000000007\n\n        self.kernel(\n            (1,), (256,),
            (\n                self.sigma, c2c_indptr, c2c_indices, c2v_indptr, c2v_indices,\n                self.lits_idx, self.lits_sign, lit_clusters_ptr, valid_clusters,\n                cp.int32(num_valid), cp.int32(self.steps_flips),\n                cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed)\n            )\n        )\n\n\n    def step(self, omega, verbose=False):\n        # --- PHASE 1: Standard Cluster Dynamics ---\n        c_spins = self.sigma[self.lits_idx]\n        \n        s0, s1, s2 = c_spins[:, 0], c_spins[:, 1], c_spins[:, 2]\n        sat0 = (s0 * s1 * self.J_tri[:, 0] == 1)\n        sat1 = (s1 * s2 * self.J_tri[:, 1] == 1)\n        sat2 = (s2 * s0 * self.J_tri[:, 2] == 1)\n        sat_mask = cp.stack([sat0, sat1, sat2], axis=1)\n        num_sat_tri = cp.sum(sat_mask, axis=1)\n        is_low_energy = (num_sat_tri == 2)\n\n        P = 1.0 - cp.exp(-omega)\n        rand_vals = cp.random.random(self.M, dtype=cp.float32)\n        src_nodes, dst_nodes = [], []\n\n        mask_T = is_low_energy & (rand_vals < P)\n        if cp.any(mask_T):\n            idx_T = cp.where(mask_T)[0]\n            r_vals_T = rand_vals[idx_T]\n            sub_sat = sat_mask[idx_T]\n            idx_1st = cp.argmax(sub_sat, axis=1)\n            idx_sum = cp.sum(sub_sat * cp.array([0, 1, 2], dtype=cp.int8), axis=1)\n            idx_2nd = idx_sum - idx_1st\n            chosen = cp.where(r_vals_T < (P / 2.0), idx_1st, idx_2nd)\n            lits = self.lits_idx[idx_T]\n            l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]\n            s_e = cp.where(chosen==0, l0, cp.where(chosen==1, l1, l2))\n            d_e = cp.where(chosen==0, l1, cp.where(chosen==1, l2, l0))\n            src_nodes.append(s_e)\n            dst_nodes.append(d_e)\n\n        if len(src_nodes) > 0:\n            all_src = cp.concatenate(src_nodes)\n            all_dst = cp.concatenate(dst_nodes)\n            data = cp.ones(len(all_src), dtype=cp.float32)\n            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N, self.N))\n            n_comps, labels = cpx_graph.connected_components(adj, directed=False)\n        else:\n            n_comps = self.N\n            labels = cp.arange(self.N, dtype=cp.int32)\n\n        if verbose:\n            comp_sizes = cp.bincount(labels)\n            sorted_sizes = cp.sort(comp_sizes)[::-1]\n            top20 = sorted_sizes[:20].get() if hasattr(sorted_sizes, 'get') else sorted_sizes[:20]\n            print(f"Phase 1: {n_comps} clusters. Top 20 sizes: {top20}")\n\n        self._run_dynamics(labels, n_comps, omega)\n        \n        # --- PHASE 2: UNSAT Percolation + ErdÅ‘s-RÃ©nyi Super-Clustering ---\n        \n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        is_unsat = (cp.sum(lit_is_sat, axis=1) == 0)\n        \n        if cp.any(is_unsat):\n            # omega_2 unused for percolation now, but used for dynamics\n            omega_2 = 8.0 * omega\n            \n            idx_U = cp.where(is_unsat)[0]\n            n_unsat = len(idx_U)\n            r_vals_U = cp.random.random(n_unsat, dtype=cp.float32)\n            \n            src_2, dst_2 = [], []\n            \n            # New Probabilities (Always freeze something)\n            # [0, 2/7) -> Edge 0\n            # [2/7, 4/7) -> Edge 1\n            # [4/7, 6/7) -> Edge 2\n            # [6/7, 1.0) -> Full Freeze\n            \n            T1 = 2.0 / 7.0\n            T2 = 4.0 / 7.0\n            T3 = 6.0 / 7.0\n            \n            # Full Freeze\n            mask_full = (r_vals_U >= T3)\n            if cp.any(mask_full):\n                l = self.lits_idx[idx_U[mask_full]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n            \n            # Single Edges\n            mask_e0 = (r_vals_U < T1)\n            if cp.any(mask_e0):\n                l = self.lits_idx[idx_U[mask_e0]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                \n            mask_e1 = (r_vals_U >= T1) & (r_vals_U < T2)\n            if cp.any(mask_e1):\n                l = self.lits_idx[idx_U[mask_e1]]\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n                \n            mask_e2 = (r_vals_U >= T2) & (r_vals_U < T3)\n            if cp.any(mask_e2):\n                l = self.lits_idx[idx_U[mask_e2]]\n                src_2.append(l[:,2]); dst_2.append(l[:,0])\n            # Build Graph Phase 2\n            if len(src_2) > 0:\n                all_src_2 = cp.concatenate(src_2)\n                all_dst_2 = cp.concatenate(dst_2)\n                data_2 = cp.ones(len(all_src_2), dtype=cp.float32)\n                adj_2 = cpx.coo_matrix((data_2, (all_src_2, all_dst_2)), shape=(self.N, self.N))\n                n_comps_2, labels_2 = cpx_graph.connected_components(adj_2, directed=False)\n            else:\n                n_comps_2 = self.N\n                labels_2 = cp.arange(self.N, dtype=cp.int32)\n                \n            # --- ERDOS-RENYI SUPER-CLUSTERING (STRICT FILTER) ---\n            \n            # Get all vars in UNSAT clauses\n            unsat_vars = self.lits_idx[idx_U].flatten()\n            \n            # Get their clusters\n            active_clusters = labels_2[unsat_vars]\n            unique_active = cp.unique(active_clusters)\n            \n            m = len(unique_active)\n            final_labels = labels_2 # Default\n            final_n_comps = n_comps_2 # Default\n            \n            if m > 1 and self.a > 0:\n                cluster_map = cp.full(n_comps_2, -1, dtype=cp.int32)\n                cluster_map[unique_active] = cp.arange(m, dtype=cp.int32)\n                \n                num_edges = int(self.a * (m - 1) / 2)\n                if num_edges > 0:\n                    s_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    d_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    data_er = cp.ones(num_edges, dtype=cp.float32)\n                    adj_er = cpx.coo_matrix((data_er, (s_er, d_er)), shape=(m, m))\n                    n_super, super_labels = cpx_graph.connected_components(adj_er, directed=False)\n                    \n                    mapped_ids = cluster_map[labels_2] # Size N. -1 if inactive.\n                    is_active = (mapped_ids != -1)\n                    \n                    new_labels = cp.zeros(self.N, dtype=cp.int32)\n                    new_labels[:] = -1\n                    new_labels[is_active] = super_labels[mapped_ids[is_active]]\n                    \n                    final_labels = new_labels\n                    final_n_comps = n_super # Only count the active super clusters\n            \n            if verbose:\n                # Stats only on active super clusters\n                active_mask = (final_labels != -1)\n                if cp.any(active_mask):\n                    comp_sizes_2 = cp.bincount(final_labels[active_mask])\n                    sorted_sizes_2 = cp.sort(comp_sizes_2)[::-1]\n                    top20_2 = sorted_sizes_2[:20].get() if hasattr(sorted_sizes_2, 'get') else sorted_sizes_2[:20]\n                    print(f"Phase 2: {n_comps_2} clusters -> {final_n_comps_2} super-clusters (Active). Top 20 sizes: {top20_2}")\n                else:\n                    print("Phase 2: No active clusters.")\n\n            self._run_dynamics(final_labels, final_n_comps, omega_2)\n\n        e = self.energy_check()\n        if e < self.min_energy:\n            self.min_energy = e\n            self.best_sigma = self.sigma.copy()\n            if e == 0.0:\n                print(f"ðŸŽ‰ SOLUTION FOUND ! (Energy = 0.0) ðŸŽ‰")\n        \n        return e, 0.0, 0.0")

# --- CELL 6: ConstrainedSwendsenWangErdosRenyiGPU ---
add_cell("# @title 3b. The Solver: `ConstrainedSwendsenWangErdosRenyiGPU`\n\nclass ConstrainedSwendsenWangErdosRenyiGPU:\n    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, a=0.9, dynamics=\"Metropolis\"):\n        self.N = N\n        self.M = len(clauses_np)\n        self.clauses = cp.array(clauses_np)\n        self.beta_scale = beta_scale\n        self.a = a\n        self.dynamics = dynamics\n        \n        if steps_flips is None:\n            self.steps_flips = 2 * N\n        else:\n            self.steps_flips = steps_flips\n\n        # Literals: 1-based indices (0 is Ghost)\n        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32))\n        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))\n\n        # Interactions (Triangles)\n        s = self.lits_sign\n        j01 = cp.where(s[:, 0] == s[:, 1], -1, 1)\n        j12 = cp.where(s[:, 1] == s[:, 2], -1, 1)\n        j20 = cp.where(s[:, 2] == s[:, 0], -1, 1)\n        self.J_tri = cp.stack([j01, j12, j20], axis=1).astype(cp.int8)\n\n        # State (Size N+1, Index 0 is Ghost)\n        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N+1)\n        self.sigma[0] = 1 # Ghost fixed to +1\n        \n        self.best_sigma = self.sigma.copy()\n        self.min_energy = 1.0\n\n        # Kernel\n        self.kernel = cp.RawKernel(metropolis_kernel_code, 'run_metropolis_dynamics', options=('-std=c++17',))\n\n    def energy_check(self):\n        spins = self.sigma[self.lits_idx]\n        is_lit_sat = (spins == self.lits_sign)\n        is_clause_sat = cp.any(is_lit_sat, axis=1)\n        return 1.0 - cp.mean(is_clause_sat)\n\n    def _run_dynamics(self, labels, n_comps, omega):\n        # Lit clusters\n        lit_clusters = labels[self.lits_idx]\n        \n        # Valid Clusters: Unique labels excluding Ghost cluster and Inactive (-1)\n        ghost_label = labels[0]\n        valid_clusters = cp.unique(labels).astype(cp.int32)\n        \n        # Filter: Exclude Ghost and Negative (Inactive)\n        valid_clusters = valid_clusters[(valid_clusters != ghost_label) & (valid_clusters >= 0)]\n        num_valid = len(valid_clusters)\n        \n        if num_valid == 0: return\n\n        # 1. CSR: Cluster -> Vars\n        # Check active vars (those with valid positive labels)\n        valid_mask_v = (labels >= 0)\n        active_vars = cp.where(valid_mask_v)[0]\n        active_labels = labels[valid_mask_v]\n        \n        if len(active_vars) == 0: return\n\n        data_v = cp.ones(len(active_vars), dtype=cp.bool_)\n        cluster_to_vars = cpx.coo_matrix(\n            (data_v, (active_labels, active_vars)),\n            shape=(n_comps, self.N + 1)\n        ).tocsr()\n\n        # 2. CSR: Cluster -> Clauses\n        flat_clusters = lit_clusters.flatten()\n        flat_clauses = cp.repeat(cp.arange(self.M), 3)\n        \n        mask_c = (flat_clusters >= 0)\n        flat_clusters = flat_clusters[mask_c]\n        flat_clauses = flat_clauses[mask_c]\n        \n        if len(flat_clusters) == 0: return\n\n        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)\n        unique_keys = cp.unique(combined_keys)\n        \n        u_clusters = (unique_keys // self.M).astype(cp.int32)\n        u_clauses = (unique_keys % self.M).astype(cp.int32)\n        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)\n        \n        cluster_to_clauses = cpx.coo_matrix(\n            (data_c, (u_clusters, u_clauses)),\n            shape=(n_comps, self.M)\n        ).tocsr()\n\n        c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)\n        c2c_indices = cluster_to_clauses.indices.astype(cp.int32)\n        c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)\n        c2v_indices = cluster_to_vars.indices.astype(cp.int32)\n        lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))\n        \n        seed = int(time.time() * 1000) % 1000000007\n\n        self.kernel(\n            (1,), (256,),
            (\n                self.sigma, c2c_indptr, c2c_indices, c2v_indptr, c2v_indices,\n                self.lits_idx, self.lits_sign, lit_clusters_ptr, valid_clusters,\n                cp.int32(num_valid), cp.int32(self.steps_flips),\n                cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed)\n            )\n        )\n\n    def step(self, omega, verbose=False):\n        # --- PHASE 1: Constrained Percolation ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        is_clause_sat = cp.any(lit_is_sat, axis=1)\n        \n        is_unsat_clause = ~is_clause_sat\n        marked_vars = cp.zeros(self.N + 1, dtype=bool)\n        if cp.any(is_unsat_clause):\n            unsat_vars = self.lits_idx[is_unsat_clause].flatten()\n            marked_vars[unsat_vars] = True\n            \n        lit_marked = marked_vars[self.lits_idx] \n        num_marked = cp.sum(lit_marked, axis=1)\n\n        s0, s1, s2 = c_spins[:, 0], c_spins[:, 1], c_spins[:, 2]\n        sat0 = (s0 * s1 * self.J_tri[:, 0] == 1)\n        sat1 = (s1 * s2 * self.J_tri[:, 1] == 1)\n        sat2 = (s2 * s0 * self.J_tri[:, 2] == 1)\n        sat_mask = cp.stack([sat0, sat1, sat2], axis=1)\n        num_sat_tri = cp.sum(sat_mask, axis=1)\n        \n        num_lit_sat = cp.sum(lit_is_sat, axis=1)\n        is_fully_sat = (num_lit_sat == 3)\n        is_low_energy = (num_sat_tri == 2)\n\n        P = 1.0 - cp.exp(-omega)\n        rand_vals = cp.random.random(self.M, dtype=cp.float32)\n        \n        src_nodes, dst_nodes = [], []\n\n        # B. Low Energy\n        mask_B = is_low_energy & (rand_vals < P)\n        if cp.any(mask_B):\n            idx_B = cp.where(mask_B)[0]\n            nm_B = num_marked[idx_B]\n            \n            mask_B1 = (nm_B == 0)\n            if cp.any(mask_B1):\n                idx_B1 = idx_B[mask_B1]\n                sub_sat = sat_mask[idx_B1]\n                idx_1st = cp.argmax(sub_sat, axis=1)\n                idx_sum = cp.sum(sub_sat * cp.array([0, 1, 2], dtype=cp.int8), axis=1)\n                idx_2nd = idx_sum - idx_1st\n                \n                pick_first = (rand_vals[idx_B1] < (P / 2.0))\n                chosen = cp.where(pick_first, idx_1st, idx_2nd)\n                \n                lits = self.lits_idx[idx_B1]\n                l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]\n                s_e = cp.where(chosen==0, l0, cp.where(chosen==1, l1, l2))\n                d_e = cp.where(chosen==0, l1, cp.where(chosen==1, l2, l0))\n                src_nodes.append(s_e); dst_nodes.append(d_e)\n                \n            mask_B2 = (nm_B == 1)\n            if cp.any(mask_B2):\n                idx_B2 = idx_B[mask_B2]\n                marked_col = cp.argmax(lit_marked[idx_B2], axis=1)\n                opp_edge = (marked_col + 1) % 3\n                is_opp_sat = sat_mask[idx_B2, opp_edge]\n                \n                if cp.any(is_opp_sat):\n                    sub_idx = idx_B2[is_opp_sat]\n                    target_edge = opp_edge[is_opp_sat]\n                    lits = self.lits_idx[sub_idx]\n                    l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]\n                    s_e = cp.where(target_edge==0, l0, cp.where(target_edge==1, l1, l2))\n                    d_e = cp.where(target_edge==0, l1, cp.where(target_edge==1, l2, l0))\n                    src_nodes.append(s_e); dst_nodes.append(d_e)\n\n        if len(src_nodes) > 0:\n            all_src = cp.concatenate(src_nodes)\n            all_dst = cp.concatenate(dst_nodes)\n            data = cp.ones(len(all_src), dtype=cp.float32)\n            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N + 1, self.N + 1))\n            n_comps, labels = cpx_graph.connected_components(adj, directed=False)\n        else:\n            n_comps = self.N + 1\n            labels = cp.arange(self.N + 1, dtype=cp.int32)\n\n        if verbose:\n            comp_sizes = cp.bincount(labels)\n            sorted_sizes = cp.sort(comp_sizes)[::-1]\n            top20 = sorted_sizes[:20].get() if hasattr(sorted_sizes, 'get') else sorted_sizes[:20]\n            print(f"Phase 1 (Constrained): {n_comps} clusters. Top 20 sizes: {top20}")\n\n        self._run_dynamics(labels, n_comps, omega)\n        \n        # --- PHASE 2 ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        is_unsat = (cp.sum(lit_is_sat, axis=1) == 0)\n        \n        if cp.any(is_unsat):\n            omega_2 = 8.0 * omega\n            \n            idx_U = cp.where(is_unsat)[0]\n            n_unsat = len(idx_U)\n            r_vals_U = cp.random.random(n_unsat, dtype=cp.float32)\n            \n            src_2, dst_2 = [], []\n            \n            T1, T2, T3 = 2.0 / 7.0, 4.0 / 7.0, 6.0 / 7.0\n            \n            # Full Freeze\n            mask_full = (r_vals_U >= T3)\n            if cp.any(mask_full):\n                l = self.lits_idx[idx_U[mask_full]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n            \n            # Single Edges\n            mask_e0 = (r_vals_U < T1)\n            if cp.any(mask_e0):\n                l = self.lits_idx[idx_U[mask_e0]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                \n            mask_e1 = (r_vals_U >= T1) & (r_vals_U < T2)\n            if cp.any(mask_e1):\n                l = self.lits_idx[idx_U[mask_e1]]\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n                \n            mask_e2 = (r_vals_U >= T2) & (r_vals_U < T3)\n            if cp.any(mask_e2):\n                l = self.lits_idx[idx_U[mask_e2]]\n                src_2.append(l[:,2]); dst_2.append(l[:,0])\n            if len(src_2) > 0:\n                all_src_2 = cp.concatenate(src_2)\n                all_dst_2 = cp.concatenate(dst_2)\n                data_2 = cp.ones(len(all_src_2), dtype=cp.float32)\n                adj_2 = cpx.coo_matrix((data_2, (all_src_2, all_dst_2)), shape=(self.N + 1, self.N + 1))\n                n_comps_2, labels_2 = cpx_graph.connected_components(adj_2, directed=False)\n            else:\n                n_comps_2 = self.N + 1\n                labels_2 = cp.arange(self.N + 1, dtype=cp.int32)\n                \n            unsat_vars = self.lits_idx[idx_U].flatten()\n            active_clusters = labels_2[unsat_vars]\n            unique_active = cp.unique(active_clusters)\n            \n            ghost_l2 = labels_2[0]\n            unique_active = unique_active[unique_active != ghost_l2]\n            \n            m = len(unique_active)\n            final_labels = labels_2\n            final_n_comps = n_comps_2\n            \n            if m > 1 and self.a > 0:\n                cluster_map = cp.full(n_comps_2, -1, dtype=cp.int32)\n                cluster_map[unique_active] = cp.arange(m, dtype=cp.int32)\n                \n                num_edges = int(self.a * (m - 1) / 2)\n                if num_edges > 0:\n                    s_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    d_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    data_er = cp.ones(num_edges, dtype=cp.float32)\n                    adj_er = cpx.coo_matrix((data_er, (s_er, d_er)), shape=(m, m))\n                    n_super, super_labels = cpx_graph.connected_components(adj_er, directed=False)\n                    \n                    mapped_ids = cluster_map[labels_2]\n                    is_active = (mapped_ids != -1)\n                    \n                    new_labels = cp.full(self.N + 1, -1, dtype=cp.int32)\n                    new_labels[is_active] = super_labels[mapped_ids[is_active]]\n                    final_labels = new_labels\n                    final_n_comps = n_super\n            \n            if verbose:\n                active_mask = (final_labels != -1)\n                if cp.any(active_mask):\n                    comp_sizes_2 = cp.bincount(final_labels[active_mask])\n                    sorted_sizes_2 = cp.sort(comp_sizes_2)[::-1]\n                    top20_2 = sorted_sizes_2[:20].get() if hasattr(sorted_sizes_2, 'get') else sorted_sizes_2[:20]\n                    print(f"Phase 2: {n_comps_2} clusters -> {final_n_comps} super-clusters (Active). Top 20 sizes: {top20_2}")\n\n            self._run_dynamics(final_labels, final_n_comps, omega_2)\n\n        e = self.energy_check()\n        if e < self.min_energy:\n            self.min_energy = e\n            self.best_sigma = self.sigma.copy()\n            if e == 0.0:\n                print(f"ðŸŽ‰ SOLUTION FOUND ! (Energy = 0.0) ðŸŽ‰")\n        \n        return e, 0.0, 0.0")

# --- CELL 7: SwendsenWangGlauberGPU ---
add_cell("# @title 3c. The Solver: `SwendsenWangGlauberGPU`\n\nclass SwendsenWangGlauberGPU:\n    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, dynamics=\"Metropolis-Hastings\"):\n        self.N = N\n        self.M = len(clauses_np)\n        self.clauses = cp.array(clauses_np)\n        self.GHOST = 0\n        self.beta_scale = beta_scale\n        if steps_flips is None:\n            self.steps_flips = 2 * N\n        else:\n            self.steps_flips = steps_flips\n        self.dynamics = dynamics\n\n        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32))\n        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))\n\n        s = self.lits_sign\n        j01 = cp.where(s[:, 0] == s[:, 1], -1, 1)\n        j12 = cp.where(s[:, 1] == s[:, 2], -1, 1)\n        j20 = cp.where(s[:, 2] == s[:, 0], -1, 1)\n        self.J_tri = cp.stack([j01, j12, j20], axis=1).astype(cp.int8)\n\n        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N+1)\n        self.sigma[0] = 1\n        \n        self.best_sigma = self.sigma.copy()\n        self.min_energy = 1.0\n\n        self.kernel = cp.RawKernel(metropolis_kernel_code, 'run_metropolis_dynamics', options=('-std=c++17',))\n\n    def energy_check(self):\n        spins = self.sigma[self.lits_idx]\n        is_lit_sat = (spins == self.lits_sign)\n        is_clause_sat = cp.any(is_lit_sat, axis=1)\n        return 1.0 - cp.mean(is_clause_sat)\n\n    def step(self, omega, verbose=False):\n        # --- 1. CLUSTERING ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        num_lit_sat = cp.sum(lit_is_sat, axis=1)\n        is_fully_sat = (num_lit_sat == 3)\n\n        s0, s1, s2 = c_spins[:, 0], c_spins[:, 1], c_spins[:, 2]\n        sat0 = (s0 * s1 * self.J_tri[:, 0] == 1)\n        sat1 = (s1 * s2 * self.J_tri[:, 1] == 1)\n        sat2 = (s2 * s0 * self.J_tri[:, 2] == 1)\n        sat_mask = cp.stack([sat0, sat1, sat2], axis=1)\n        num_sat_tri = cp.sum(sat_mask, axis=1)\n        is_low_energy = (num_sat_tri == 2)\n\n        P = 1.0 - cp.exp(-omega)\n        rand_vals = cp.random.random(self.M, dtype=cp.float32)\n\n        src_nodes = []\n        dst_nodes = []\n\n        # --- B1. Ghost Connections (Fully SAT Clauses) ---\n        mask_G = is_fully_sat & (rand_vals < P)\n        if cp.any(mask_G):\n            idx_G = cp.where(mask_G)[0]\n            targets = self.lits_idx[idx_G].flatten()\n            src_nodes.append(cp.zeros_like(targets)) # Connect to Ghost (0) \n            dst_nodes.append(targets)\n\n        # B2. Internal\n        mask_T = is_low_energy & (rand_vals < P)\n        if cp.any(mask_T):\n            idx_T = cp.where(mask_T)[0]\n            r_vals_T = rand_vals[idx_T]\n            sub_sat = sat_mask[idx_T]\n            idx_1st = cp.argmax(sub_sat, axis=1)\n            idx_sum = cp.sum(sub_sat * cp.array([0, 1, 2], dtype=cp.int8), axis=1)\n            idx_2nd = idx_sum - idx_1st\n            P_2 = P / 2.0\n            pick_first = (r_vals_T < P_2)\n            chosen_edge_idx = cp.where(pick_first, idx_1st, idx_2nd)\n            lits = self.lits_idx[idx_T]\n            l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]\n            s_e = cp.where(chosen_edge_idx==0, l0, cp.where(chosen_edge_idx==1, l1, l2))\n            d_e = cp.where(chosen_edge_idx==0, l1, cp.where(chosen_edge_idx==1, l2, l0))\n            src_nodes.append(s_e)\n            dst_nodes.append(d_e)\n\n        if len(src_nodes) > 0:\n            all_src = cp.concatenate(src_nodes)\n            all_dst = cp.concatenate(dst_nodes)\n            data = cp.ones(len(all_src), dtype=cp.float32)\n            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N+1, self.N+1), dtype=cp.float32)\n            n_comps, labels = cpx_graph.connected_components(adj, directed=False)\n        else:\n            n_comps = self.N + 1\n            labels = cp.arange(self.N + 1, dtype=cp.int32)\n\n        # Stats\n        comp_sizes = cp.bincount(labels)\n        sorted_sizes = cp.sort(comp_sizes)[::-1]\n        c1_frac = sorted_sizes[0] / (self.N + 1)\n        c2_frac = sorted_sizes[1] / (self.N + 1) if n_comps > 1 else 0.0\n        if verbose:\n            print(f"Phase 1 Top 7 Clusters: {sorted_sizes[:7]}")\n\n        # --- 2. DYNAMICS (KERNEL) ---\n        lit_clusters = labels[self.lits_idx] # (M, 3)\n\n        data_v = cp.ones(self.N + 1, dtype=cp.bool_)\n        cluster_to_vars = cpx.coo_matrix(\n            (data_v, (labels, cp.arange(self.N + 1))),\n            shape=(n_comps, self.N + 1)\n        ).tocsr()\n\n        flat_clusters = lit_clusters.flatten()\n        flat_clauses = cp.repeat(cp.arange(self.M), 3)\n        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)\n        unique_keys = cp.unique(combined_keys)\n        u_clusters = (unique_keys // self.M).astype(cp.int32)\n        u_clauses = (unique_keys % self.M).astype(cp.int32)\n        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)\n\n        cluster_to_clauses = cpx.coo_matrix(\n            (data_c, (u_clusters, u_clauses)),\n            shape=(n_comps, self.M)\n        ).tocsr()\n\n        ghost_label = labels[0]\n        unique_labels = cp.unique(labels)\n        valid_clusters = unique_labels[unique_labels != ghost_label].astype(cp.int32)\n        num_valid = len(valid_clusters)\n\n        if num_valid > 0:\n            c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)\n            c2c_indices = cluster_to_clauses.indices.astype(cp.int32)\n            c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)\n            c2v_indices = cluster_to_vars.indices.astype(cp.int32)\n\n            lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))\n\n            seed = int(time.time() * 1000) % 1000000007\n\n            self.kernel(\n                (1,), (256,),
                (\n                    self.sigma,\n                    c2c_indptr, c2c_indices,\n                    c2v_indptr, c2v_indices,\n                    self.lits_idx, self.lits_sign,\n                    lit_clusters_ptr,\n                    valid_clusters,\n                    cp.int32(num_valid),\n                    cp.int32(self.steps_flips),\n                    cp.float32(omega),\n                    cp.float32(self.beta_scale),\n                    cp.uint64(seed)\n                )\n            )\n\n        # --- PHASE 2: UNSAT DYNAMICS ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        num_lit_sat = cp.sum(lit_is_sat, axis=1)\n        is_unsat = (num_lit_sat == 0)\n\n        P = 1.0 - cp.exp(-omega)\n        # 2. Percolation on UNSAT Clauses ONLY\n        src_nodes_2 = []\n        dst_nodes_2 = []\n\n        if cp.any(is_unsat):\n            idx_U = cp.where(is_unsat)[0]\n            n_unsat = len(idx_U)\n            r_vals_U = cp.random.random(n_unsat, dtype=cp.float32)\n            \n            P_7 = P / 7.0\n            \n            mask_full = (r_vals_U >= 6.0 * P_7) & (r_vals_U < P)\n            if cp.any(mask_full):\n                sub_idx = idx_U[mask_full]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 0]); dst_nodes_2.append(lits[:, 1])\n                src_nodes_2.append(lits[:, 1]); dst_nodes_2.append(lits[:, 2])\n            \n            mask_e0 = (r_vals_U < 2.0 * P_7)\n            if cp.any(mask_e0):\n                sub_idx = idx_U[mask_e0]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 0]); dst_nodes_2.append(lits[:, 1])\n\n            mask_e1 = (r_vals_U >= 2.0 * P_7) & (r_vals_U < 4.0 * P_7)\n            if cp.any(mask_e1):\n                sub_idx = idx_U[mask_e1]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 1]); dst_nodes_2.append(lits[:, 2])\n\n            mask_e2 = (r_vals_U >= 4.0 * P_7) & (r_vals_U < 6.0 * P_7)\n            if cp.any(mask_e2):\n                sub_idx = idx_U[mask_e2]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 2]); dst_nodes_2.append(lits[:, 0])\n\n        if len(src_nodes_2) > 0:\n            all_src_2 = cp.concatenate(src_nodes_2)\n            all_dst_2 = cp.concatenate(dst_nodes_2)\n            data_2 = cp.ones(len(all_src_2), dtype=cp.float32)\n            adj_2 = cpx.coo_matrix((data_2, (all_src_2, all_dst_2)), shape=(self.N+1, self.N+1), dtype=cp.float32)\n            n_comps_2, labels_2 = cpx_graph.connected_components(adj_2, directed=False)\n        else:\n            n_comps_2 = self.N + 1\n            labels_2 = cp.arange(self.N + 1, dtype=cp.int32)\n\n        comp_sizes_2 = cp.bincount(labels_2)\n        if verbose:\n            sorted_sizes_2 = cp.sort(comp_sizes_2)[::-1]\n            print(f"Phase 2 Top 7 Clusters: {sorted_sizes_2[:7]}")\n\n        lit_clusters_2 = labels_2[self.lits_idx]\n        data_v_2 = cp.ones(self.N + 1, dtype=cp.bool_)\n        cluster_to_vars_2 = cpx.coo_matrix((data_v_2, (labels_2, cp.arange(self.N + 1))), shape=(n_comps_2, self.N + 1)).tocsr()\n        flat_clusters_2 = lit_clusters_2.flatten()\n        flat_clauses_2 = cp.repeat(cp.arange(self.M), 3)\n        combined_keys_2 = flat_clusters_2.astype(cp.int64) * self.M + flat_clauses_2.astype(cp.int64)\n        unique_keys_2 = cp.unique(combined_keys_2)\n        u_clusters_2 = (unique_keys_2 // self.M).astype(cp.int32)\n        u_clauses_2 = (unique_keys_2 % self.M).astype(cp.int32)\n        data_c_2 = cp.ones(len(u_clusters_2), dtype=cp.bool_)\n        cluster_to_clauses_2 = cpx.coo_matrix((data_c_2, (u_clusters_2, u_clauses_2)), shape=(n_comps_2, self.M)).tocsr()\n\n        ghost_label_2 = labels_2[0]\n        unique_labels_2 = cp.unique(labels_2)\n        mask_valid = (comp_sizes_2[unique_labels_2] > 1) & (unique_labels_2 != ghost_label_2)\n        valid_clusters_2 = unique_labels_2[mask_valid].astype(cp.int32)\n        num_valid_2 = len(valid_clusters_2)\n\n        if num_valid_2 > 0:\n            c2c_indptr_2 = cluster_to_clauses_2.indptr.astype(cp.int32)\n            c2c_indices_2 = cluster_to_clauses_2.indices.astype(cp.int32)\n            c2v_indptr_2 = cluster_to_vars_2.indptr.astype(cp.int32)\n            c2v_indices_2 = cluster_to_vars_2.indices.astype(cp.int32)\n            lit_clusters_ptr_2 = cp.ascontiguousarray(lit_clusters_2.astype(cp.int32))\n            \n            self.kernel((1,), (256,), (self.sigma, c2c_indptr_2, c2c_indices_2, c2v_indptr_2, c2v_indices_2, self.lits_idx, self.lits_sign, lit_clusters_ptr_2, valid_clusters_2, cp.int32(num_valid_2), cp.int32(self.steps_flips), cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed + 1)))

        current_energy = self.energy_check()\n        \n        if current_energy < self.min_energy:\n            self.min_energy = current_energy\n            self.best_sigma = self.sigma.copy()\n            if self.min_energy == 0.0:\n                print(f"ðŸŽ‰ SOLUTION FOUND ! (Energy = 0.0) ðŸŽ‰")\n        \n        return current_energy, c1_frac, c2_frac")

# --- CELL 8: CompleteSwendsenWangGPU + SwendsenWangCompleteErdosRenyiGPU ---
add_cell("# @title 3d. The Solver: `CompleteSwendsenWangGPU` & `SwendsenWangCompleteErdosRenyiGPU`\n\nclass SwendsenWangCompleteErdosRenyiGPU:\n    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, a=0.9, dynamics=\"Metropolis\"):\n        self.N = N\n        self.M = len(clauses_np)\n        self.clauses = cp.array(clauses_np)\n        self.beta_scale = beta_scale\n        self.a = a\n        self.dynamics = dynamics\n        \n        if steps_flips is None:\n            self.steps_flips = 2 * N\n        else:\n            self.steps_flips = steps_flips\n\n        # Literals: 0-based\n        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32) - 1)\n        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))\n\n        # Interactions\n        s = self.lits_sign\n        j01 = cp.where(s[:, 0] == s[:, 1], -1, 1)\n        j12 = cp.where(s[:, 1] == s[:, 2], -1, 1)\n        j20 = cp.where(s[:, 2] == s[:, 0], -1, 1)\n        self.J_tri = cp.stack([j01, j12, j20], axis=1).astype(cp.int8)\n\n        # State (Size N)\n        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N)\n        \n        self.best_sigma = self.sigma.copy()\n        self.min_energy = 1.0\n\n        # Kernel\n        self.kernel = cp.RawKernel(metropolis_kernel_code, 'run_metropolis_dynamics', options=('-std=c++17',))\n\n    def energy_check(self):\n        spins = self.sigma[self.lits_idx]\n        is_lit_sat = (spins == self.lits_sign)\n        is_clause_sat = cp.any(is_lit_sat, axis=1)\n        return 1.0 - cp.mean(is_clause_sat)\n\n    def _run_dynamics(self, labels, n_comps, omega):\n        lit_clusters = labels[self.lits_idx]\n        valid_clusters = cp.unique(labels).astype(cp.int32)\n        valid_clusters = valid_clusters[valid_clusters >= 0]\n        num_valid = len(valid_clusters)\n        if num_valid == 0: return\n\n        valid_mask_v = (labels >= 0)\n        active_vars = cp.where(valid_mask_v)[0]\n        active_labels = labels[valid_mask_v]\n        if len(active_vars) == 0: return\n        data_v = cp.ones(len(active_vars), dtype=cp.bool_)\n        cluster_to_vars = cpx.coo_matrix((data_v, (active_labels, active_vars)), shape=(n_comps, self.N)).tocsr()\n\n        flat_clusters = lit_clusters.flatten()\n        flat_clauses = cp.repeat(cp.arange(self.M), 3)\n        mask_c = (flat_clusters >= 0)\n        flat_clusters = flat_clusters[mask_c]\n        flat_clauses = flat_clauses[mask_c]\n        if len(flat_clusters) == 0: return\n        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)\n        unique_keys = cp.unique(combined_keys)\n        u_clusters = (unique_keys // self.M).astype(cp.int32)\n        u_clauses = (unique_keys % self.M).astype(cp.int32)\n        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)\n        cluster_to_clauses = cpx.coo_matrix((data_c, (u_clusters, u_clauses)), shape=(n_comps, self.M)).tocsr()\n\n        c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)\n        c2c_indices = cluster_to_clauses.indices.astype(cp.int32)\n        c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)\n        c2v_indices = cluster_to_vars.indices.astype(cp.int32)\n        lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))\n        \n        seed = int(time.time() * 1000) % 1000000007\n\n        self.kernel(\n            (1,), (256,),
            (\n                self.sigma, c2c_indptr, c2c_indices, c2v_indptr, c2v_indices,\n                self.lits_idx, self.lits_sign, lit_clusters_ptr, valid_clusters,\n                cp.int32(num_valid), cp.int32(self.steps_flips),\n                cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed)\n            )\n        )\n\n    def step(self, omega, verbose=False):\n        c_spins = self.sigma[self.lits_idx]\n        \n        s0, s1, s2 = c_spins[:, 0], c_spins[:, 1], c_spins[:, 2]\n        sat0 = (s0 * s1 * self.J_tri[:, 0] == 1)\n        sat1 = (s1 * s2 * self.J_tri[:, 1] == 1)\n        sat2 = (s2 * s0 * self.J_tri[:, 2] == 1)\n        sat_mask = cp.stack([sat0, sat1, sat2], axis=1)\n        num_sat_tri = cp.sum(sat_mask, axis=1)\n        is_low_energy = (num_sat_tri == 2)\n        \n        lit_is_sat = (c_spins == self.lits_sign)\n        num_lit_sat = cp.sum(lit_is_sat, axis=1)\n        is_fully_sat = (num_lit_sat == 3)\n\n        P = 1.0 - cp.exp(-omega)\n        rand_vals = cp.random.random(self.M, dtype=cp.float32)\n        src_nodes, dst_nodes = [], []\n\n        mask_B = is_low_energy & (rand_vals < P)\n        if cp.any(mask_B):\n            idx_B = cp.where(mask_B)[0]\n            r_vals_B = rand_vals[idx_B]\n            sub_sat = sat_mask[idx_B]\n            idx_1st = cp.argmax(sub_sat, axis=1)\n            idx_sum = cp.sum(sub_sat * cp.array([0, 1, 2], dtype=cp.int8), axis=1)\n            idx_2nd = idx_sum - idx_1st\n            pick_first = (r_vals_B < (P / 2.0))\n            chosen = cp.where(pick_first, idx_1st, idx_2nd)\n            lits = self.lits_idx[idx_B]\n            l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]\n            s_e = cp.where(chosen==0, l0, cp.where(chosen==1, l1, l2))\n            d_e = cp.where(chosen==0, l1, cp.where(chosen==1, l2, l0))\n            src_nodes.append(s_e); dst_nodes.append(d_e)\n\n        if len(src_nodes) > 0:\n            all_src = cp.concatenate(src_nodes)\n            all_dst = cp.concatenate(dst_nodes)\n            data = cp.ones(len(all_src), dtype=cp.float32)\n            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N, self.N))\n            n_comps, labels = cpx_graph.connected_components(adj, directed=False)\n        else:\n            n_comps = self.N\n            labels = cp.arange(self.N, dtype=cp.int32)\n\n        m = n_comps\n        final_labels_1 = labels\n        final_n_comps_1 = n_comps\n        \n        if m > 1 and self.a > 0:\n            num_edges = int(self.a * (m - 1) / 2)\n            if num_edges > 0:\n                s_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                d_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                data_er = cp.ones(num_edges, dtype=cp.float32)\n                adj_er = cpx.coo_matrix((data_er, (s_er, d_er)), shape=(m, m))\n                n_super, super_labels = cpx_graph.connected_components(adj_er, directed=False)\n                final_labels_1 = super_labels[labels]\n                final_n_comps_1 = n_super\n\n        self._run_dynamics(final_labels_1, final_n_comps_1, omega)\n        \n        # --- PHASE 2: UNSAT Percolation + ER ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        is_unsat = (cp.sum(lit_is_sat, axis=1) == 0)\n        \n        if cp.any(is_unsat):\n            omega_2 = 8.0 * omega\n            \n            idx_U = cp.where(is_unsat)[0]\n            n_unsat = len(idx_U)\n            r_vals_U = cp.random.random(n_unsat, dtype=cp.float32)\n            \n            src_2, dst_2 = [], []\n            T1, T2, T3 = 2.0 / 7.0, 4.0 / 7.0, 6.0 / 7.0\n            \n            mask_full = (r_vals_U >= T3)\n            if cp.any(mask_full):\n                l = self.lits_idx[idx_U[mask_full]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n            \n            mask_e0 = (r_vals_U < T1)\n            if cp.any(mask_e0):\n                l = self.lits_idx[idx_U[mask_e0]]\n                src_2.append(l[:,0]); dst_2.append(l[:,1])\n                \n            mask_e1 = (r_vals_U >= T1) & (r_vals_U < T2)\n            if cp.any(mask_e1):\n                l = self.lits_idx[idx_U[mask_e1]]\n                src_2.append(l[:,1]); dst_2.append(l[:,2])\n                \n            mask_e2 = (r_vals_U >= T2) & (r_vals_U < T3)\n            if cp.any(mask_e2):\n                l = self.lits_idx[idx_U[mask_e2]]\n                src_2.append(l[:,2]); dst_2.append(l[:,0])\n            if len(src_2) > 0:\n                all_src_2 = cp.concatenate(src_2)\n                all_dst_2 = cp.concatenate(dst_2)\n                data_2 = cp.ones(len(all_src_2), dtype=cp.float32)\n                adj_2 = cpx.coo_matrix((data_2, (all_src_2, all_dst_2)), shape=(self.N, self.N))\n                n_comps_2, labels_2 = cpx_graph.connected_components(adj_2, directed=False)\n            else:\n                n_comps_2 = self.N\n                labels_2 = cp.arange(self.N, dtype=cp.int32)\n                \n            unsat_vars = self.lits_idx[idx_U].flatten()\n            active_clusters = labels_2[unsat_vars]\n            unique_active = cp.unique(active_clusters)\n            m = len(unique_active)\n            final_labels_2 = labels_2\n            final_n_comps_2 = n_comps_2\n            \n            if m > 1 and self.a > 0:\n                cluster_map = cp.full(n_comps_2, -1, dtype=cp.int32)\n                cluster_map[unique_active] = cp.arange(m, dtype=cp.int32)\n                num_edges = int(self.a * (m - 1) / 2)\n                if num_edges > 0:\n                    s_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    d_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)\n                    data_er = cp.ones(num_edges, dtype=cp.float32)\n                    adj_er = cpx.coo_matrix((data_er, (s_er, d_er)), shape=(m, m))\n                    n_super, super_labels = cpx_graph.connected_components(adj_er, directed=False)\n                    mapped_ids = cluster_map[labels_2]\n                    is_active = (mapped_ids != -1)\n                    new_labels = cp.full(self.N, -1, dtype=cp.int32)\n                    new_labels[is_active] = super_labels[mapped_ids[is_active]]\n                    final_labels_2 = new_labels\n                    final_n_comps_2 = n_super\n            \n            if verbose:\n                active_mask = (final_labels_2 != -1)\n                if cp.any(active_mask):\n                    comp_sizes_2 = cp.bincount(final_labels_2[active_mask])\n                    sorted_sizes_2 = cp.sort(comp_sizes_2)[::-1]\n                    top20_2 = sorted_sizes_2[:20].get() if hasattr(sorted_sizes_2, 'get') else sorted_sizes_2[:20]\n                    print(f"Phase 2: {n_comps_2} clusters -> {final_n_comps_2} super-clusters (Active). Top 20: {top20_2}")\n\n            self._run_dynamics(final_labels_2, final_n_comps_2, omega_2)\n\n        e = self.energy_check()\n        if e < self.min_energy:\n            self.min_energy = e\n            self.best_sigma = self.sigma.copy()\n            if e == 0.0:\n                print(f"ðŸŽ‰ SOLUTION FOUND ! (Energy = 0.0) ðŸŽ‰")\n        \n        return e, 0.0, 0.0\n\nclass CompleteSwendsenWangGPU:\n    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, dynamics=\"Metropolis-Hastings\"):\n        self.N = N\n        self.M = len(clauses_np)\n        self.clauses = cp.array(clauses_np)\n        self.beta_scale = beta_scale\n        if steps_flips is None:\n            self.steps_flips = 2 * N\n        else:\n            self.steps_flips = steps_flips\n        self.dynamics = dynamics\n\n        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32))\n        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))\n\n        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N+1)\n        self.sigma[0] = 1 # Dummy index 0\n        \n        self.best_sigma = self.sigma.copy()\n        self.min_energy = 1.0\n\n        # Reusing the Glauber kernel\n        self.kernel = cp.RawKernel(metropolis_kernel_code, 'run_metropolis_dynamics', options=('-std=c++17',))\n\n    def energy_check(self):\n        spins = self.sigma[self.lits_idx]\n        is_lit_sat = (spins == self.lits_sign)\n        is_clause_sat = cp.any(is_lit_sat, axis=1)\n        return 1.0 - cp.mean(is_clause_sat)\n\n    def step(self, omega, verbose=False):\n        P = 1.0 - cp.exp(-omega)\n        rand_vals = cp.random.random(self.M, dtype=cp.float32)\n        \n        src_nodes = []\n        dst_nodes = []\n        \n        P_7 = P / 7.0\n        \n        # Range [6P/7, P) -> Full Freeze\n        mask_full = (rand_vals >= 6.0 * P_7) & (rand_vals < P)\n        if cp.any(mask_full):\n            sub_idx = cp.where(mask_full)[0]\n            lits = self.lits_idx[sub_idx]\n            # Edge 0-1\n            src_nodes.append(lits[:, 0])\n            dst_nodes.append(lits[:, 1])\n            # Edge 1-2\n            src_nodes.append(lits[:, 1])\n            dst_nodes.append(lits[:, 2])\n            \n        # Edge 0 (0-1)\n        mask_e0 = (rand_vals < 2.0 * P_7)\n        if cp.any(mask_e0):\n            sub_idx = cp.where(mask_e0)[0]\n            lits = self.lits_idx[sub_idx]\n            src_nodes.append(lits[:, 0])\n            dst_nodes.append(lits[:, 1])\n            \n        # Edge 1 (1-2)\n        mask_e1 = (rand_vals >= 2.0 * P_7) & (rand_vals < 4.0 * P_7)\n        if cp.any(mask_e1):\n            sub_idx = cp.where(mask_e1)[0]\n            lits = self.lits_idx[sub_idx]\n            src_nodes.append(lits[:, 1])\n            dst_nodes.append(lits[:, 2])\n            \n        # Edge 2 (2-0)\n        mask_e2 = (rand_vals >= 4.0 * P_7) & (rand_vals < 6.0 * P_7)\n        if cp.any(mask_e2):\n            sub_idx = cp.where(mask_e2)[0]\n            lits = self.lits_idx[sub_idx]\n            src_nodes.append(lits[:, 2])\n            dst_nodes.append(lits[:, 0])\n\n        if len(src_nodes) > 0:\n            all_src = cp.concatenate(src_nodes)\n            all_dst = cp.concatenate(dst_nodes)\n            data = cp.ones(len(all_src), dtype=cp.float32)\n            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N+1, self.N+1), dtype=cp.float32)\n            n_comps, labels = cpx_graph.connected_components(adj, directed=False)\n        else:\n            n_comps = self.N + 1\n            labels = cp.arange(self.N + 1, dtype=cp.int32)\n\n        if verbose:\n            comp_sizes = cp.bincount(labels)\n            sorted_sizes = cp.sort(comp_sizes)[::-1]\n            print(f"Complete SW Top 7 Clusters: {sorted_sizes[:7]}")\n\n        lit_clusters = labels[self.lits_idx]\n        \n        data_v = cp.ones(self.N + 1, dtype=cp.bool_)\n        cluster_to_vars = cpx.coo_matrix((data_v, (labels, cp.arange(self.N + 1))), shape=(n_comps, self.N + 1)).tocsr()\n        \n        flat_clusters = lit_clusters.flatten()\n        flat_clauses = cp.repeat(cp.arange(self.M), 3)\n        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)\n        unique_keys = cp.unique(combined_keys)\n        u_clusters = (unique_keys // self.M).astype(cp.int32)\n        u_clauses = (unique_keys % self.M).astype(cp.int32)\n        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)\n        cluster_to_clauses = cpx.coo_matrix((data_c, (u_clusters, u_clauses)), shape=(n_comps, self.M)).tocsr()\n        \n        # Exclude dummy 0\n        ghost_label = labels[0]\n        unique_labels = cp.unique(labels)\n        valid_clusters = unique_labels[unique_labels != ghost_label].astype(cp.int32)\n        num_valid = len(valid_clusters)\n        \n        if num_valid > 0:\n            c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)\n            c2c_indices = cluster_to_clauses.indices.astype(cp.int32)\n            c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)\n            c2v_indices = cluster_to_vars.indices.astype(cp.int32)\n            lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))\n            \n            seed = int(time.time() * 1000) % 1000000007\n            self.kernel((1,), (256,), (self.sigma, c2c_indptr, c2c_indices, c2v_indptr, c2v_indices, self.lits_idx, self.lits_sign, lit_clusters_ptr, valid_clusters, cp.int32(num_valid), cp.int32(self.steps_flips), cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed)))
            \n        # --- PHASE 2: UNSAT DYNAMICS (8x Boost) ---\n        c_spins = self.sigma[self.lits_idx]\n        lit_is_sat = (c_spins == self.lits_sign)\n        num_lit_sat = cp.sum(lit_is_sat, axis=1)\n        is_unsat = (num_lit_sat == 0)\n\n        if cp.any(is_unsat):\n            omega_2 = 8.0 * omega\n            P_2 = 1.0 - cp.exp(-omega_2)\n            idx_U = cp.where(is_unsat)[0]\n            n_unsat = len(idx_U)\n            r_vals_U = cp.random.random(n_unsat, dtype=cp.float32)\n            \n            src_nodes_2 = []\n            dst_nodes_2 = []\n            \n            P_7 = P_2 / 7.0\n            \n            mask_full = (r_vals_U >= 6.0 * P_7) & (r_vals_U < P_2)\n            if cp.any(mask_full):\n                sub_idx = idx_U[mask_full]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 0]); dst_nodes_2.append(lits[:, 1])\n                src_nodes_2.append(lits[:, 1]); dst_nodes_2.append(lits[:, 2])\n\n            mask_e0 = (r_vals_U < 2.0 * P_7)\n            if cp.any(mask_e0):\n                sub_idx = idx_U[mask_e0]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 0]); dst_nodes_2.append(lits[:, 1])\n\n            mask_e1 = (r_vals_U >= 2.0 * P_7) & (r_vals_U < 4.0 * P_7)\n            if cp.any(mask_e1):\n                sub_idx = idx_U[mask_e1]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 1]); dst_nodes_2.append(lits[:, 2])\n\n            mask_e2 = (r_vals_U >= 4.0 * P_7) & (r_vals_U < 6.0 * P_7)\n            if cp.any(mask_e2):\n                sub_idx = idx_U[mask_e2]\n                lits = self.lits_idx[sub_idx]\n                src_nodes_2.append(lits[:, 2]); dst_nodes_2.append(lits[:, 0])\n\n            if len(src_nodes_2) > 0:\n                all_src_2 = cp.concatenate(src_nodes_2)\n                all_dst_2 = cp.concatenate(dst_nodes_2)\n                data_2 = cp.ones(len(all_src_2), dtype=cp.float32)\n                adj_2 = cpx.coo_matrix((data_2, (all_src_2, all_dst_2)), shape=(self.N+1, self.N+1), dtype=cp.float32)\n                n_comps_2, labels_2 = cpx_graph.connected_components(adj_2, directed=False)\n            else:\n                n_comps_2 = self.N + 1\n                labels_2 = cp.arange(self.N + 1, dtype=cp.int32)\n\n            if verbose:\n                comp_sizes_2 = cp.bincount(labels_2)\n                sorted_sizes_2 = cp.sort(comp_sizes_2)[::-1]\n                print(f"Complete SW Phase 2 (UNSAT) Top 7 Clusters: {sorted_sizes_2[:7]}")\n\n            unsat_vars = self.lits_idx[idx_U].flatten()\n            relevant_clusters = labels_2[unsat_vars]\n            unique_relevant = cp.unique(relevant_clusters)\n            ghost_label_2 = labels_2[0]\n            valid_clusters_2 = unique_relevant[unique_relevant != ghost_label_2].astype(cp.int32)\n            num_valid_2 = len(valid_clusters_2)\n\n            if num_valid_2 > 0:\n                lit_clusters_2 = labels_2[self.lits_idx]\n                data_v_2 = cp.ones(self.N + 1, dtype=cp.bool_)\n                cluster_to_vars_2 = cpx.coo_matrix((data_v_2, (labels_2, cp.arange(self.N + 1))), shape=(n_comps_2, self.N + 1)).tocsr()\n                flat_clusters_2 = lit_clusters_2.flatten()\n                flat_clauses_2 = cp.repeat(cp.arange(self.M), 3)\n                combined_keys_2 = flat_clusters_2.astype(cp.int64) * self.M + flat_clauses_2.astype(cp.int64)\n                unique_keys_2 = cp.unique(combined_keys_2)\n                u_clusters_2 = (unique_keys_2 // self.M).astype(cp.int32)\n                u_clauses_2 = (unique_keys_2 % self.M).astype(cp.int32)\n                data_c_2 = cp.ones(len(u_clusters_2), dtype=cp.bool_)\n                cluster_to_clauses_2 = cpx.coo_matrix((data_c_2, (u_clusters_2, u_clauses_2)), shape=(n_comps_2, self.M)).tocsr()\n\n                c2c_indptr_2 = cluster_to_clauses_2.indptr.astype(cp.int32)\n                c2c_indices_2 = cluster_to_clauses_2.indices.astype(cp.int32)\n                c2v_indptr_2 = cluster_to_vars_2.indptr.astype(cp.int32)\n                c2v_indices_2 = cluster_to_vars_2.indices.astype(cp.int32)\n                lit_clusters_ptr_2 = cp.ascontiguousarray(lit_clusters_2.astype(cp.int32))\n                \n                self.kernel((1,), (256,), (self.sigma, c2c_indptr_2, c2c_indices_2, c2v_indptr_2, c2v_indices_2, self.lits_idx, self.lits_sign, lit_clusters_ptr_2, valid_clusters_2, cp.int32(num_valid_2), cp.int32(self.steps_flips), cp.float32(omega_2), cp.float32(self.beta_scale), cp.uint64(seed + 100)))

        current_energy = self.energy_check()\n        if current_energy < self.min_energy:\n            self.min_energy = current_energy\n            self.best_sigma = self.sigma.copy()\n            if self.min_energy == 0.0:\n                print("ðŸŽ‰ COMPLETE SOLUTION FOUND ! (Energy = 0.0) ðŸŽ‰")\n                \n        return current_energy, 0.0, 0.0")

# --- CELL 9: DynamicsUNSAT_GPU (NEW) ---
add_cell("# @title 3e. The New Solver: `DynamicsUNSAT_GPU`\n\ndynamics_unsat_kernel_code = r'''\n#include <curand_kernel.h>\n\nextern \"C\" __global__ void run_dynamics_unsat(\n    signed char* sigma,           // N\n    const int* c2c_indptr,        // n_comps + 1\n    const int* c2c_indices,       // n_clauses_refs\n    const int* c2v_indptr,        // n_comps + 1\n    const int* c2v_indices,       // n_vars_refs\n    const int* lits_idx,          // M * 3\n    const signed char* lits_sign, // M * 3\n    const int* lit_clusters,      // M * 3\n    const int* valid_clusters,    // num_valid\n    int num_valid,\n    int steps,\n    float omega,\n    float beta_scale,\n    unsigned long long seed,\n    int require_unsat             // 0 = Normal, 1 = Only clusters touching UNSAT clauses\n) {\n    __shared__ int delta_E_shared;\n    __shared__ int decision_shared;\n    __shared__ int target_cluster_shared;\n    __shared__ int is_cluster_active; \n\n    curandState state;\n    if (threadIdx.x == 0) curand_init(seed, 0, 0, &state);\n\n    for (int step = 0; step < steps; step++) {\n        __syncthreads();\n\n        // --- 1. Pick Target Cluster ---\n        if (threadIdx.x == 0) {\n            delta_E_shared = 0;\n            decision_shared = 0;\n            is_cluster_active = (require_unsat) ? 0 : 1; \n            \n            unsigned int r = curand(&state);\n            int r_idx = r % num_valid;\n            target_cluster_shared = valid_clusters[r_idx];\n        }\n        __syncthreads();\n\n        int c_id = target_cluster_shared;\n        int start_c = c2c_indptr[c_id];\n        int end_c = c2c_indptr[c_id+1];\n\n        // --- 2. DYNAMIC CHECK ---\n        if (require_unsat && start_c < end_c) {\n            for (int i = start_c + threadIdx.x; i < end_c; i += blockDim.x) {\n                if (is_cluster_active) break; \n\n                int clause_idx = c2c_indices[i];\n                int idx0 = clause_idx * 3 + 0;\n                int idx1 = clause_idx * 3 + 1;\n                int idx2 = clause_idx * 3 + 2;\n\n                bool sat = (sigma[lits_idx[idx0]] == lits_sign[idx0]) ||\n                           (sigma[lits_idx[idx1]] == lits_sign[idx1]) ||\n                           (sigma[lits_idx[idx2]] == lits_sign[idx2]);\n                \n                if (!sat) {\n                    is_cluster_active = 1; \n                }\n            }\n        }\n        __syncthreads();\n\n        if (is_cluster_active == 0) continue; \n\n        // --- 3. Compute Delta E ---\n        if (start_c < end_c) {\n            for (int i = start_c + threadIdx.x; i < end_c; i += blockDim.x) {\n                int clause_idx = c2c_indices[i];\n                \n                int idx0 = clause_idx * 3 + 0;\n                int idx1 = clause_idx * 3 + 1;\n                int idx2 = clause_idx * 3 + 2;\n\n                int l0 = lits_idx[idx0];\n                int l1 = lits_idx[idx1];\n                int l2 = lits_idx[idx2];\n\n                signed char s0 = lits_sign[idx0];\n                signed char s1 = lits_sign[idx1];\n                signed char s2 = lits_sign[idx2];\n\n                signed char sig0 = sigma[l0];\n                signed char sig1 = sigma[l1];\n                signed char sig2 = sigma[l2];\n\n                int cl0 = lit_clusters[idx0];\n                int cl1 = lit_clusters[idx1];\n                int cl2 = lit_clusters[idx2];\n\n                bool sat_curr = (sig0 == s0) || (sig1 == s1) || (sig2 == s2);\n\n                signed char p_sig0 = (cl0 == c_id) ? -sig0 : sig0;\n                signed char p_sig1 = (cl1 == c_id) ? -sig1 : sig1;\n                signed char p_sig2 = (cl2 == c_id) ? -sig2 : sig2;\n\n                bool sat_new = (p_sig0 == s0) || (p_sig1 == s1) || (p_sig2 == s2);\n\n                if (sat_curr != sat_new) {\n                    atomicAdd(&delta_E_shared, (int)sat_curr - (int)sat_new);\n                }\n            }\n        }\n        __syncthreads();\n\n        // --- 4. Decision ---\n        if (threadIdx.x == 0) {\n            int dE = delta_E_shared;\n            if (dE <= 0) {\n                decision_shared = 1;\n            } else {\n                float p = expf(-(float)dE * omega * beta_scale);\n                if (curand_uniform(&state) < p) {\n                    decision_shared = 1;\n                }\n            }\n        }\n        __syncthreads();\n\n        // --- 5. Update ---\n        if (decision_shared) {\n            int start_v = c2v_indptr[c_id];\n            int end_v = c2v_indptr[c_id+1];\n            for (int i = start_v + threadIdx.x; i < end_v; i += blockDim.x) {\n                sigma[c2v_indices[i]] *= -1;\n            }\n        }\n    }\n}\n'''

class DynamicsUNSAT_GPU:
    def __init__(self, clauses_np, N, beta_scale=15.0, steps_flips=None, a=0.9):
        self.N = N
        self.M = len(clauses_np)
        self.clauses = cp.array(clauses_np)
        self.beta_scale = beta_scale
        self.a = a
        if steps_flips is None:
            self.steps_flips = 2 * N
        else:
            self.steps_flips = steps_flips

        self.lits_idx = cp.ascontiguousarray(cp.abs(self.clauses).astype(cp.int32) - 1)
        self.lits_sign = cp.ascontiguousarray(cp.sign(self.clauses).astype(cp.int8))

        s = self.lits_sign
        j01 = cp.where(s[:, 0] == s[:, 1], -1, 1)
        j12 = cp.where(s[:, 1] == s[:, 2], -1, 1)
        j20 = cp.where(s[:, 2] == s[:, 0], -1, 1)
        self.J_tri = cp.stack([j01, j12, j20], axis=1).astype(cp.int8)

        self.sigma = cp.random.choice(cp.array([-1, 1], dtype=cp.int8), size=N)
        self.best_sigma = self.sigma.copy()
        self.min_energy = 1.0
        self.kernel = cp.RawKernel(dynamics_unsat_kernel_code, 'run_dynamics_unsat', options=('-std=c++17',))

    def energy_check(self):
        spins = self.sigma[self.lits_idx]
        is_lit_sat = (spins == self.lits_sign)
        is_clause_sat = cp.any(is_lit_sat, axis=1)
        return 1.0 - cp.mean(is_clause_sat)

    def _run_dynamics(self, labels, n_comps, omega, require_unsat=0):
        lit_clusters = labels[self.lits_idx]
        valid_clusters = cp.unique(labels).astype(cp.int32)
        valid_clusters = valid_clusters[valid_clusters >= 0]
        num_valid = len(valid_clusters)
        if num_valid == 0: return

        valid_mask_v = (labels >= 0)
        active_vars = cp.where(valid_mask_v)[0]
        active_labels = labels[valid_mask_v]
        if len(active_vars) == 0: return
        data_v = cp.ones(len(active_vars), dtype=cp.bool_)
        cluster_to_vars = cpx.coo_matrix((data_v, (active_labels, active_vars)), shape=(n_comps, self.N)).tocsr()

        flat_clusters = lit_clusters.flatten()
        flat_clauses = cp.repeat(cp.arange(self.M), 3)
        mask_c = (flat_clusters >= 0)
        flat_clusters = flat_clusters[mask_c]
        flat_clauses = flat_clauses[mask_c]
        if len(flat_clusters) == 0: return
        combined_keys = flat_clusters.astype(cp.int64) * self.M + flat_clauses.astype(cp.int64)
        unique_keys = cp.unique(combined_keys)
        u_clusters = (unique_keys // self.M).astype(cp.int32)
        u_clauses = (unique_keys % self.M).astype(cp.int32)
        data_c = cp.ones(len(u_clusters), dtype=cp.bool_)
        cluster_to_clauses = cpx.coo_matrix((data_c, (u_clusters, u_clauses)), shape=(n_comps, self.M)).tocsr()

        c2c_indptr = cluster_to_clauses.indptr.astype(cp.int32)
        c2c_indices = cluster_to_clauses.indices.astype(cp.int32)
        c2v_indptr = cluster_to_vars.indptr.astype(cp.int32)
        c2v_indices = cluster_to_vars.indices.astype(cp.int32)
        lit_clusters_ptr = cp.ascontiguousarray(lit_clusters.astype(cp.int32))
        seed = int(time.time() * 1000) % 1000000007

        self.kernel(
            (1,), (256,),
            (
                self.sigma, c2c_indptr, c2c_indices, c2v_indptr, c2v_indices,
                self.lits_idx, self.lits_sign, lit_clusters_ptr, valid_clusters,
                cp.int32(num_valid), cp.int32(self.steps_flips),
                cp.float32(omega), cp.float32(self.beta_scale), cp.uint64(seed),
                cp.int32(require_unsat)
            )
        )

    def step(self, omega, verbose=False):
        c_spins = self.sigma[self.lits_idx]
        s0, s1, s2 = c_spins[:, 0], c_spins[:, 1], c_spins[:, 2]
        sat0 = (s0 * s1 * self.J_tri[:, 0] == 1)
        sat1 = (s1 * s2 * self.J_tri[:, 1] == 1)
        sat2 = (s2 * s0 * self.J_tri[:, 2] == 1)
        sat_mask = cp.stack([sat0, sat1, sat2], axis=1)
        num_sat_tri = cp.sum(sat_mask, axis=1)
        is_low_energy = (num_sat_tri == 2)

        P = 1.0 - cp.exp(-omega)
        rand_vals = cp.random.random(self.M, dtype=cp.float32)
        src_nodes, dst_nodes = [], []

        mask_T = is_low_energy & (rand_vals < P)
        if cp.any(mask_T):
            idx_T = cp.where(mask_T)[0]
            r_vals_T = rand_vals[idx_T]
            sub_sat = sat_mask[idx_T]
            idx_1st = cp.argmax(sub_sat, axis=1)
            idx_sum = cp.sum(sub_sat * cp.array([0, 1, 2], dtype=cp.int8), axis=1)
            idx_2nd = idx_sum - idx_1st
            chosen = cp.where(r_vals_T < (P / 2.0), idx_1st, idx_2nd)
            lits = self.lits_idx[idx_T]
            l0, l1, l2 = lits[:,0], lits[:,1], lits[:,2]
            s_e = cp.where(chosen==0, l0, cp.where(chosen==1, l1, l2))
            d_e = cp.where(chosen==0, l1, cp.where(chosen==1, l2, l0))
            src_nodes.append(s_e); dst_nodes.append(d_e)

        if len(src_nodes) > 0:
            all_src = cp.concatenate(src_nodes)
            all_dst = cp.concatenate(dst_nodes)
            data = cp.ones(len(all_src), dtype=cp.float32)
            adj = cpx.coo_matrix((data, (all_src, all_dst)), shape=(self.N, self.N))
            n_comps, labels = cpx_graph.connected_components(adj, directed=False)
        else:
            n_comps = self.N
            labels = cp.arange(self.N, dtype=cp.int32)

        m = n_comps
        final_labels = labels
        final_n_comps = n_comps
        if m > 1 and self.a > 0:
            num_edges = int(self.a * (m - 1) / 2)
            if num_edges > 0:
                s_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)
                d_er = cp.random.randint(0, m, size=num_edges, dtype=cp.int32)
                data_er = cp.ones(num_edges, dtype=cp.float32)
                adj_er = cpx.coo_matrix((data_er, (s_er, d_er)), shape=(m, m))
                n_super, super_labels = cpx_graph.connected_components(adj_er, directed=False)
                final_labels = super_labels[labels]
                final_n_comps = n_super

        self._run_dynamics(final_labels, final_n_comps, omega, require_unsat=0)
        omega_2 = 8.0 * omega
        self._run_dynamics(final_labels, final_n_comps, omega_2, require_unsat=1)

        e = self.energy_check()
        if e < self.min_energy:
            self.min_energy = e
            self.best_sigma = self.sigma.copy()
            if e == 0.0: print("SOLUTION FOUND!")
        
        return e, 0.0, 0.0")

# --- CELL 10: WalkSAT ---
add_cell("# @title 4. Baseline: `WalkSAT` (CPU Optimized)\nclass WalkSAT:\n    def __init__(self, clauses_np, N):\n        self.N = N\n        self.clauses = clauses_np \n        self.M = len(clauses_np)\n        self.sigma = np.random.choice([-1, 1], size=N+1)\n        self.sigma[0] = 1\n\n    def evaluate(self):\n        lits = self.clauses\n        s = self.sigma[np.abs(lits)]\n        sat = (lits * s) > 0\n        clause_sat = np.any(sat, axis=1)\n        return np.where(~clause_sat)[0], 1.0 - np.mean(clause_sat)\n\n    def step(self, flips=1):\n        p = 0.5\n        unsat_indices, energy = self.evaluate()\n        if len(unsat_indices) == 0: return 0.0\n\n        for _ in range(flips):\n            if len(unsat_indices) == 0: break\n            clause_idx = np.random.choice(unsat_indices)\n            clause = self.clauses[clause_idx]\n            vars_in_clause = np.abs(clause)\n\n            if np.random.random() < p:\n                target = np.random.choice(vars_in_clause)\n            else:\n                # Simplified Greedy\n                target = vars_in_clause[0] # Placeholder for full greedy logic\n\n            self.sigma[target] *= -1\n        \n        # Fast Noise Step\n        current_unsat, _ = self.evaluate()\n        if len(current_unsat) == 0: return 0.0\n        target_clause = np.random.choice(current_unsat)\n        vars_c = np.abs(self.clauses[target_clause])\n        v_flip = np.random.choice(vars_c)\n        self.sigma[v_flip] *= -1\n\n        _, e = self.evaluate()\n        return e")

# --- CELL 11: Main Loop ---
add_cell("# @title 5. Main Simulation Loop\nN = 10000\nalpha = 4.0 \nclauses_np, _ = generate_random_3sat(N, alpha, seed=42)\nprint(f"Instance: N={N}, M={len(clauses_np)}, Alpha={alpha}")\n\n# Solvers\nsolver_er = SwendsenWangErdosRenyiGPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N, a=0.9)\nsolver_constrained = ConstrainedSwendsenWangErdosRenyiGPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N, a=0.9)\nsolver_complete_er = SwendsenWangCompleteErdosRenyiGPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N, a=0.9)\nsolver_gl = SwendsenWangGlauberGPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N)\nsolver_complete = CompleteSwendsenWangGPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N)\nsolver_dyn = DynamicsUNSAT_GPU(clauses_np, N, beta_scale=100.0, steps_flips=2*N, a=0.9)\nwalksat = WalkSAT(clauses_np, N)\n\nsteps = 10000\nomega_min = 0.05\nomega_max = 0.2\n\nepsilon = 1e-4\nraw_decay = np.geomspace(1, epsilon, steps)\ndecay_01 = (raw_decay - epsilon) / (1.0 - epsilon)\nomega_schedule = omega_max - (omega_max - omega_min) * decay_01\n\n# History\nhistory_er = []\nhistory_const = []\nhistory_c_er = []\nhistory_gl = []\nhistory_cp = []\nhistory_ws = []\nhistory_dyn = []\n\nt0 = time.time()\nprint("Starting Comparison...")\n\nfor i, omega in enumerate(omega_schedule):\n    is_verbose = (i % 50 == 0)
    
    # 1. ER-SW
    unsat_er, _, _ = solver_er.step(omega, verbose=False)
    history_er.append(float(unsat_er.get()) if hasattr(unsat_er, 'get') else float(unsat_er))

    # 2. Constrained ER-SW
    unsat_const, _, _ = solver_constrained.step(omega, verbose=False)
    history_const.append(float(unsat_const.get()) if hasattr(unsat_const, 'get') else float(unsat_const))

    # 3. Complete ER-SW
    unsat_c_er, _, _ = solver_complete_er.step(omega, verbose=is_verbose)
    history_c_er.append(float(unsat_c_er.get()) if hasattr(unsat_c_er, 'get') else float(unsat_c_er))

    # 4. SW Glauber
    unsat_gl, _, _ = solver_gl.step(omega, verbose=False)
    history_gl.append(float(unsat_gl.get()) if hasattr(unsat_gl, 'get') else float(unsat_gl))
    
    # 5. Complete SW
    unsat_cp, _, _ = solver_complete.step(omega, verbose=False)
    history_cp.append(float(unsat_cp.get()) if hasattr(unsat_cp, 'get') else float(unsat_cp))

    # 6. Dynamics UNSAT (New)
    unsat_dyn, _, _ = solver_dyn.step(omega, verbose=False)
    history_dyn.append(float(unsat_dyn.get()) if hasattr(unsat_dyn, 'get') else float(unsat_dyn))

    # 7. WalkSAT
    flips_per_step = N // 10000
    if flips_per_step < 1: flips_per_step = 1
    e_ws = 1.0
    for _ in range(flips_per_step):
        e_ws = walksat.step(flips=1)
        if e_ws == 0.0: break
    history_ws.append(e_ws)

    if is_verbose:
        print(f"Step {i:4d} | w={omega:.3f} | ER: {unsat_er:.5f} | CST: {unsat_const:.5f} | C-ER: {unsat_c_er:.5f} | DYN: {unsat_dyn:.5f} | GL: {unsat_gl:.5f} | CP: {unsat_cp:.5f} | WS: {e_ws:.5f}")
        if unsat_c_er == 0.0: print("COMPLETE-ER SOLVED!"); break
        if unsat_const == 0.0: print("CONST SOLVED!"); break
        if unsat_er == 0.0: print("ER SOLVED!"); break
        if unsat_dyn == 0.0: print("DYN SOLVED!"); break

dt = time.time() - t0
print(f"Done in {dt:.2f}s")

# Plot
omega_cpu = omega_schedule[:len(history_er)]
er_cpu = np.array(history_er)
const_cpu = np.array(history_const)
c_er_cpu = np.array(history_c_er)
gl_cpu = np.array(history_gl)
cp_cpu = np.array(history_cp)
ws_cpu = np.array(history_ws)
dyn_cpu = np.array(history_dyn)

plt.figure(figsize=(12, 7))
ax1 = plt.gca()

l1, = ax1.plot(omega_cpu, er_cpu, label='Erdos-Renyi SW', color='cyan', linewidth=1.5, alpha=0.5)
l2, = ax1.plot(omega_cpu, const_cpu, label='Constrained ER-SW', color='magenta', linewidth=1.5, alpha=0.5)
l3, = ax1.plot(omega_cpu, c_er_cpu, label='Complete ER-SW', color='white', linewidth=2.5)
l4, = ax1.plot(omega_cpu, gl_cpu, label='Glauber', color='lime', linewidth=1.5, linestyle=':', alpha=0.5)
l5, = ax1.plot(omega_cpu, cp_cpu, label='Complete', color='yellow', linewidth=1.5, linestyle=':', alpha=0.5)
l6, = ax1.plot(omega_cpu, ws_cpu, label='WalkSAT', color='red', alpha=0.5)
l7, = ax1.plot(omega_cpu, dyn_cpu, label='Dynamics UNSAT', color='orange', linewidth=2.0)

ax1.set_xlabel(r'Coupling $\\omega$ (Time)')
ax1.set_ylabel('Fraction Unsatisfied', color='white')
ax1.tick_params(axis='y', labelcolor='white')
ax1.grid(True, alpha=0.2)

ax1.legend(loc='upper right')
plt.title(f'Solver Comparison (N={N}, Alpha={alpha})')
plt.show()
")

with open("Swendsen-Wang_3SAT_Colab.ipynb", "w", encoding="utf-8") as f:
    json.dump(notebook, f, indent=1)

print("Notebook generated successfully.")
```